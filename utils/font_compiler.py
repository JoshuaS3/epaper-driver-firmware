#!/usr/bin/env python3

# File:
#   esp32-heltec-epd/font_compiler.py
# Description:
#   Parses bitfonts from https://github.com/robhagemans/hoard-of-bitfonts and
#   formats them as C source files, usable by this component's draw functions
#   to render on Heltec ePaper display
#
# "esp32-heltec-epd" Copyright (c) 2023 Joshua Stockin
# <josh@joshstock.in> [https://joshstock.in] [https://github.com/JoshuaS3]
#
# This software is licensed and distributed under the terms of the MIT License.
# See the MIT License in the LICENSE file of this project's root folder.
#
# This comment block and its contents, including this disclaimer, MUST be
# preserved in all copies or distributions of this software's source.

import os
import urllib.request
from dataclasses import dataclass, field
import pprint


CURRENT_DIR = os.path.realpath(os.path.dirname(__file__))
FONTS_DIR = os.path.join(CURRENT_DIR, "..", "src", "fonts")
ROOT_FONT_URI = (
    "https://raw.githubusercontent.com/robhagemans/hoard-of-bitfonts/master/"
)
FONTS = {
    # MS Serif 8, 10, 12, 14, 18, 24
    "Serif8": "windows/windows-3.1/ms-serif-e/MS_Serif_8.yaff",
    "Serif10": "windows/windows-3.1/ms-serif-e/MS_Serif_10.yaff",
    "Serif12": "windows/windows-3.1/ms-serif-e/MS_Serif_12.yaff",
    "Serif14": "windows/windows-3.1/ms-serif-e/MS_Serif_14.yaff",
    "Serif18": "windows/windows-3.1/ms-serif-e/MS_Serif_18.yaff",
    "Serif24": "windows/windows-3.1/ms-serif-e/MS_Serif_24.yaff",
    # MS Sans Serif 8, 10, 12, 14, 18, 24
    "SansSerif8": "windows/windows-3.1/ms-sans-serif-e/MS_Sans_Serif_8.yaff",
    "SansSerif10": "windows/windows-3.1/ms-sans-serif-e/MS_Sans_Serif_10.yaff",
    "SansSerif12": "windows/windows-3.1/ms-sans-serif-e/MS_Sans_Serif_12.yaff",
    "SansSerif14": "windows/windows-3.1/ms-sans-serif-e/MS_Sans_Serif_14.yaff",
    "SansSerif18": "windows/windows-3.1/ms-sans-serif-e/MS_Sans_Serif_18.yaff",
    "SansSerif24": "windows/windows-3.1/ms-sans-serif-e/MS_Sans_Serif_24.yaff",
    # Helv 8, 10, 12, 14, 18, 24
    "Helv8": "windows/windows-3.0/helv-b/Helv_8.yaff",
    "Helv10": "windows/windows-3.0/helv-b/Helv_10.yaff",
    "Helv12": "windows/windows-3.0/helv-b/Helv_12.yaff",
    "Helv14": "windows/windows-3.0/helv-b/Helv_14.yaff",
    "Helv18": "windows/windows-3.0/helv-b/Helv_18.yaff",
    "Helv24": "windows/windows-3.0/helv-b/Helv_24.yaff",
    # Courier 10, 12, 15
    "Courier10": "windows/windows-3.1/courier-e/Courier_10.yaff",
    "Courier12": "windows/windows-3.1/courier-e/Courier_12.yaff",
    "Courier15": "windows/windows-3.1/courier-e/Courier_15.yaff",
}


@dataclass
class Glyph:
    name: str = ""
    byte: int = 0
    width: int = 0
    height: int = 0
    startx: int = 0
    starty: int = 0
    duplicate: int = -1
    graphical: list[str] = field(default_factory=list)
    int8arr: list[int] = field(default_factory=list)

    def __eq__(self, obj):
        return self.graphical == obj.graphical


class FontYAFF:
    def __init__(self, font_name):
        self.font_name = font_name
        self.glyphs = {}
        self.yaff_source = ""
        self.header_text = """// File generated by font_compiler.py
// FONT_{NAME}[] binary size: {SIZE}
// Generated from {URL}

#include <stdint.h>

const uint8_t FONT_{NAME}[] = {{
{DATA}
}};
"""
        self.default = 128
        self.shiftup = 0
        self.ascent = 0

    def fetch_source(self, url) -> bool:
        self.source_url = url
        resource = urllib.request.urlopen(url)
        if resource.getcode() == 200:
            self.yaff_source = resource.read().decode()
            return True
        return False

    def parse_yaff(self):
        for metadata_line in self.yaff_source.split("\n\n", 1)[0].split("\n"):
            if len(metadata_line) == 0:
                continue
            if metadata_line.startswith("shift-up"):
                self.shiftup = abs(int(metadata_line.split(": ")[1]))
            elif metadata_line.startswith("ascent"):
                self.ascent = int(metadata_line.split(": ")[1])
            elif metadata_line.startswith("default-char"):
                self.default = int(metadata_line.split(": ")[1], 16)

        for glyph_block in self.yaff_source.split("\n\n")[1:]:
            glyph_block = glyph_block.strip()
            if len(glyph_block) == 0:
                continue

            # Extract data from glyph block
            new_glyph = Glyph()
            for line in glyph_block.split("\n"):
                if len(line) == 0:
                    continue
                if line.startswith("# "):
                    new_glyph.name = line[2:]
                elif line.startswith("0x") or line.startswith("u+"):
                    new_glyph.byte = int(line[2:-1], 16)
                elif line.startswith(" " * 4):
                    new_glyph.graphical.append(line[4:])

            # Check if duplicate
            duplicate = False
            for existing_glyph in self.glyphs.values():
                if new_glyph == existing_glyph:
                    duplicate = True
                    new_glyph.duplicate = existing_glyph.byte
                    break

            if not duplicate:
                # Convert graphical representation to byte array
                new_glyph.height = len(new_glyph.graphical)
                new_glyph.width = len(new_glyph.graphical[0])
                # Trim end
                linear = "".join(new_glyph.graphical).rstrip(".")
                # Find start position
                for bit in range(0, len(linear)):
                    if linear[bit] == "@":
                        new_glyph.startx = bit % new_glyph.width
                        new_glyph.starty = bit // new_glyph.width
                        break
                # Trim start
                linear = linear.lstrip(".")
                for byte in range(0, len(linear), 8):
                    n = 0
                    for bit in range(
                        0, len(linear) - byte if len(linear) - byte < 8 else 8
                    ):
                        n ^= (linear[byte + bit] == "@") << bit
                    new_glyph.int8arr.append(n)

            self.glyphs[new_glyph.byte] = new_glyph

    def compile_header(self):  # returns static data length
        formatted_data_blocks = []
        metadata_template = """    /* Metadata block:
     * First glyph byte = {START}
     * End glyph byte = {END}
     * Ascent = {HEIGHT}
     * Shift-up = {SHIFTUP}
     * Default/fallback glyph = {DEFAULT}
     */
    {START}, {END}, {HEIGHT}, {SHIFTUP}, {DEFAULT},
"""
        data_template = """    /* {BYTE} {NAME}
     * Duplicate of = {DUPE_BYTE} (0 if not a duplicate)
     * Width = {WIDTH}
     * Pixel start X = {STARTX}
     * Pixel start Y = {STARTY}
     * Data length = {DATA_LENGTH}
     * {GRAPHICAL}
     */
{DATA}
"""
        formatted_data_blocks.append(
            metadata_template.format(
                START=str(min(self.glyphs.keys())),
                END=str(min(255, max(self.glyphs.keys()))),
                HEIGHT=self.ascent or len(self.glyphs[self.default].graphical),
                SHIFTUP=self.shiftup,
                DEFAULT=self.default,
            )
        )
        data_size = 4
        for byte in range(
            min(self.glyphs.keys()), min(255, max(self.glyphs.keys())) + 1
        ):
            glyph = None
            if byte in self.glyphs.keys():
                glyph = self.glyphs[byte]
            else:
                glyph = Glyph()
            data = [
                glyph.duplicate if glyph.duplicate != -1 else 0,
            ]
            if glyph.duplicate == -1:
                data += [
                    glyph.width,
                    glyph.startx,
                    glyph.starty,
                    len(glyph.int8arr),
                    *glyph.int8arr,
                ]
            formatted_data = (
                pprint.pformat(
                    data,
                    indent=4,
                    width=80,
                    compact=True,
                )[1:-1]
                + ","
            )
            if glyph.duplicate == -1:
                formatted_data_blocks.append(
                    data_template.format(
                        DUPE_BYTE=glyph.duplicate if glyph.duplicate != -1 else 0,
                        BYTE=byte,
                        NAME=glyph.name,
                        WIDTH=glyph.width,
                        STARTX=glyph.startx,
                        STARTY=glyph.starty,
                        DATA_LENGTH=len(glyph.int8arr),
                        GRAPHICAL="\n     * ".join(glyph.graphical),
                        DATA=formatted_data,
                    )
                )
                data_size += 5 + len(glyph.int8arr)
            else:
                formatted_data_blocks.append(
                    data_template.format(
                        DUPE_BYTE=glyph.duplicate if glyph.duplicate != -1 else 0,
                        BYTE=byte,
                        NAME=glyph.name,
                        WIDTH="None",
                        STARTX="None",
                        STARTY="None",
                        DATA_LENGTH="None",
                        GRAPHICAL="\n     * ".join(glyph.graphical),
                        DATA=formatted_data,
                    )
                )
                data_size += 1
        self.header_text = self.header_text.format(
            NAME=self.font_name.upper(),
            DATA="\n".join(formatted_data_blocks),
            SIZE=data_size,
            URL=self.source_url,
        )
        return data_size

    def write_header(self, header_file):
        buf = open(header_file, "w")
        buf.write(self.header_text)
        buf.close()


if __name__ == "__main__":

    if not os.path.exists(FONTS_DIR) or not os.path.isdir(FONTS_DIR):
        print("Creating")
        os.mkdir(FONTS_DIR)

    for font_name, font_relpath in FONTS.items():
        url = f"{ROOT_FONT_URI}{font_relpath}"
        header_file = os.path.join(FONTS_DIR, f"{font_name}.c")

        print(f"Generating source for {font_name}")
        f = FontYAFF(font_name)

        print(f"  Fetching file from {url}")
        exists = f.fetch_source(url)
        if not exists:
            print(f"    Resource does not exist")
            continue

        print("  Parsing from source")
        f.parse_yaff()
        print(f"    Found {len(f.glyphs)} characters")

        print("  Compiling header")
        size = f.compile_header()
        print(f"    Binary data size: {size} bytes")
        print(f"    File size: {len(f.header_text)} bytes")

        print(f"  Writing header ({header_file})")
        f.write_header(header_file)

    print("Finished")
