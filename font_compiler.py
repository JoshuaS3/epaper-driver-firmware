#!/usr/bin/env python3

import os
import urllib.request
from dataclasses import dataclass, field
import pprint


CURRENT_DIR = os.path.realpath(os.path.dirname(__file__))
FONTS_DIR = os.path.join(CURRENT_DIR, "fonts")
ROOT_FONT_URI = (
    "https://raw.githubusercontent.com/robhagemans/hoard-of-bitfonts/master/"
)
FONTS = {
    # MS Serif 8, 10, 12, 14, 18, 24
    "Serif8": "windows/windows-3.1/ms-serif-e/MS_Serif_8.yaff",
    "Serif10": "windows/windows-3.1/ms-serif-e/MS_Serif_10.yaff",
    "Serif12": "windows/windows-3.1/ms-serif-e/MS_Serif_12.yaff",
    "Serif14": "windows/windows-3.1/ms-serif-e/MS_Serif_14.yaff",
    "Serif18": "windows/windows-3.1/ms-serif-e/MS_Serif_18.yaff",
    "Serif24": "windows/windows-3.1/ms-serif-e/MS_Serif_24.yaff",
    # MS Sans Serif 8, 10, 12, 14, 18, 24
    "SansSerif8": "windows/windows-3.1/ms-sans-serif-e/MS_Sans_Serif_8.yaff",
    "SansSerif10": "windows/windows-3.1/ms-sans-serif-e/MS_Sans_Serif_10.yaff",
    "SansSerif12": "windows/windows-3.1/ms-sans-serif-e/MS_Sans_Serif_12.yaff",
    "SansSerif14": "windows/windows-3.1/ms-sans-serif-e/MS_Sans_Serif_14.yaff",
    "SansSerif18": "windows/windows-3.1/ms-sans-serif-e/MS_Sans_Serif_18.yaff",
    "SansSerif24": "windows/windows-3.1/ms-sans-serif-e/MS_Sans_Serif_24.yaff",
    # Helv 8, 10, 12, 14, 18, 24
    "Helv8": "windows/windows-3.0/helv-b/Helv_8.yaff",
    "Helv10": "windows/windows-3.0/helv-b/Helv_10.yaff",
    "Helv12": "windows/windows-3.0/helv-b/Helv_12.yaff",
    "Helv14": "windows/windows-3.0/helv-b/Helv_14.yaff",
    "Helv18": "windows/windows-3.0/helv-b/Helv_18.yaff",
    "Helv24": "windows/windows-3.0/helv-b/Helv_24.yaff",
}


@dataclass
class Glyph:
    name: str = ""
    byte: int = 0
    width: int = 0
    height: int = 0
    startx: int = 0
    starty: int = 0
    graphical: list[str] = field(default_factory=list)
    int8arr: list[int] = field(default_factory=list)


class FontYAFF:
    def __init__(self, font_name):
        self.font_name = font_name
        self.glyphs = {}
        self.yaff_source = ""
        self.header_text = """// File generated by font_compiler.py

#include <stdint.h>

static const uint8_t FONT_{NAME}[] = {{
{DATA}
}};
"""

    def fetch_source(self, url) -> bool:
        resource = urllib.request.urlopen(url)
        if resource.getcode() == 200:
            self.yaff_source = resource.read().decode()
            return True
        return False

    def parse_yaff(self):
        for glyph_block in self.yaff_source.split("\n\n")[1:]:
            glyph_block = glyph_block.strip()
            if len(glyph_block) == 0:
                continue

            # Extract data from glyph block
            new_glyph = Glyph()
            for line in glyph_block.split("\n"):
                if len(line) == 0:
                    continue
                if line.startswith("# "):
                    new_glyph.name = line[2:]
                elif line.startswith("0x") or line.startswith("u+"):
                    new_glyph.byte = int(line[2:-1], 16)
                elif line.startswith(" " * 4):
                    new_glyph.graphical.append(line[4:])

            # Convert graphical representation to byte array
            new_glyph.height = len(new_glyph.graphical)
            new_glyph.width = len(new_glyph.graphical[0])
            # Trim end
            linear = "".join(new_glyph.graphical).rstrip(".")
            # Find start position
            for bit in range(0, len(linear)):
                if linear[bit] == "@":
                    new_glyph.startx = bit % new_glyph.width
                    new_glyph.starty = bit // new_glyph.width
                    break
            # Trim start
            linear = linear.lstrip(".")
            for byte in range(0, len(linear), 8):
                n = 0
                for bit in range(
                    0, len(linear) - byte if len(linear) - byte < 8 else 8
                ):
                    n ^= (linear[byte + bit] == "@") << bit
                new_glyph.int8arr.append(n)
            self.glyphs[new_glyph.byte] = new_glyph

    def compile_header(self):  # returns static data length
        formatted_data_blocks = []
        metadata_template = """    /* Metadata block:
     * First glyph byte = {START}
     * End glyph byte = {END}
     * Glyph height = {HEIGHT}
     * Default/fallback glyph = {DEFAULT}
     */
    {START}, {END}, {HEIGHT}, {DEFAULT},
"""
        data_template = """    /* {BYTE} {NAME}
     * Width = {WIDTH}
     * Pixel start X = {STARTX}
     * Pixel start Y = {STARTY}
     * Data length = {DATA_LENGTH}
     * {GRAPHICAL}
     */
{DATA}
"""
        formatted_data_blocks.append(
            metadata_template.format(
                START=str(min(self.glyphs.keys())),
                END=str(min(255, max(self.glyphs.keys()))),
                HEIGHT=str(self.glyphs[80].height),
                DEFAULT=str(80),
            )
        )
        data_size = 4
        for byte in range(min(self.glyphs.keys()), max(self.glyphs.keys())):
            glyph = None
            if byte in self.glyphs.keys():
                glyph = self.glyphs[byte]
            else:
                glyph = Glyph()
            formatted_data = pprint.pformat(
                [glyph.width, glyph.startx, glyph.starty, len(glyph.int8arr), *glyph.int8arr],
                indent=4,
                width=80,
                compact=True
            )[1:-1] + ","
            formatted_data_blocks.append(
                data_template.format(
                    BYTE=str(byte),
                    NAME=str(glyph.name),
                    WIDTH=str(glyph.width),
                    STARTX=str(glyph.startx),
                    STARTY=str(glyph.starty),
                    DATA_LENGTH=str(len(glyph.int8arr)),
                    GRAPHICAL="\n     * ".join(glyph.graphical),
                    DATA=formatted_data,
                )
            )
            data_size += 4 + len(glyph.int8arr)
        self.header_text = self.header_text.format(
            NAME=self.font_name.upper(), DATA="\n".join(formatted_data_blocks)
        )
        return data_size

    def write_header(self, header_file):
        buf = open(header_file, "w")
        buf.write(self.header_text)
        buf.close()


if __name__ == "__main__":

    if not os.path.exists(FONTS_DIR) or not os.path.isdir(FONTS_DIR):
        print("Creating")
        os.mkdir(FONTS_DIR)

    for font_name, font_relpath in FONTS.items():
        url = f"{ROOT_FONT_URI}{font_relpath}"
        header_file = os.path.join(FONTS_DIR, f"{font_name}.c")

        print(f"Generating source for {font_name}")
        f = FontYAFF(font_name)

        print(f"  Fetching file from {url}")
        exists = f.fetch_source(url)
        if not exists:
            print(f"    Resource does not exist")
            continue

        print("  Parsing from source")
        f.parse_yaff()
        print(f"    Found {len(f.glyphs)} characters")

        print("  Compiling header")
        size = f.compile_header()
        print(f"    Binary data size: {size} bytes")
        print(f"    File size: {len(f.header_text)} bytes")

        print(f"  Writing header ({header_file})")
        f.write_header(header_file)

    print("Finished")
